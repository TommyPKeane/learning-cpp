# Examples of Build Systems/Approaches for C++

This directory contains separate project folders with some trivial C++ source code to be able to show different approaches to managing the compilation of the source code into executables or libraries.

<!-- MarkdownTOC -->

- [Compatibility Note](#compatibility-note)
- [Build Variants](#build-variants)
    - [`bash` Scripting](#bash-scripting)
    - [GNU Make with Makefiles](#gnu-make-with-makefiles)
    - [CMake as an alternative to GNU Make](#cmake-as-an-alternative-to-gnu-make)
    - [Bazel Build System](#bazel-build-system)
- [References](#references)

<!-- /MarkdownTOC -->

<a id="compatibility-note"></a>
## Compatibility Note

Note that we're currently developing and testing these examples with macOS, so even if some or all of these should be portable to other systems, they may not be configured as such, here.

So if you're not on macOS, please note that these may not all run exactly as documented.

<a id="build-variants"></a>
## Build Variants

Each build variant directory uses a different build management approach, where they each have differing levels of complexity involved in using them.

If you're using this code to help decide which approach to take, you'll want to make sure to consider the complexity of the project you're working on, and how extensible you want it to be.

In general, if the setup is simple for a certain approach, then it likely is very limited in functionality and will probably lack extensibility. If you have a growing project and will be incorporating separate directories and libraries and will be making multi-stage builds or want to have configurable build targets, you're going to likely want to lean towards the more "complex" tooling, since it's trade-off in initial-setup-complexity will be rewards in extensibility and portability.

<a id="bash-scripting"></a>
### `bash` Scripting

All the build tools are likely run from a `bash` (or Terminal shell) command, but you could also just write your own custom scripts in `bash` to do all the steps of your build processes.

You can do something as simple as making a separate `.sh` script file for each build "target" you want to manage, or you could even try to create a set of `bash` functions with command parsing to make your complex script that handles different options and configurations when it's called.

Using `bash` is arguably the simplest and easiest approach to understand, since you're basically directly calling the compiler, linker, and all those build-support tools directly. But this also makes this the most fragile and least extensible "build system", because unless you start stacking complexity into your scripting, you're going to have something basically very transparent and very fragile (unable to adapt) where you're likely going to be rewriting the scripts over-and-over as your project grows in complexity.

<a id="gnu-make-with-makefiles"></a>
### GNU Make with Makefiles

One step up from `bash` scripting is using the Unix tool `make`, which has a GNU variant known as GNU Make (`gmake` if you're on macOS and install it with `brew`).

`make` (or `gmake`) extends from the `bash` scripting syntax to support new commands and scripting structure with things called "`make` targets", which are like `bash` functions that run a series of commands and operations related to your build. There's a whole set of logic related to interdependence and fallback/callbacks between `make` targets which are arguably much more appealing and featureful than trying to come up with something all on your own through `bash`.

<a id="cmake-as-an-alternative-to-gnu-make"></a>
### CMake as an alternative to GNU Make

One of the major complaints with GNU Make is that if you have a lot of separate, intermediate builds to run in generating your final project build, you're going to have to create and manage all those separate Makefiles, and then create a hierarchy of other Makefiles that call all those independent builds before running the dependent builds.

If you only have 1 layer of dependency in your overall project build, this may not seem like that much of a problem. But, if you start to have numerous interdependences between your separate builds, or if you have several layers of dependent builds, this starts to be become a really fragile system, since you'll have to deal with all those relationships intentionally through the design of the Makefiles themselves.

With CMake, the idea is that you let the CMake application be aware of everything you want to build, and any dependence that each element has on any others, and then CMake takes this web of interdependence between them all and creates a bunch of GNU Makefiles, and then manages the calling of all those autogenerated Makefiles.

If it sounds complicated, it's because it is. But the benefits you get are that you now have a build system where you don't personally have to figure out all the complexities of build dependencies, and you get progress indicators and all kinds of fancy things that would otherwise take a lot of effort for you to generate in your own GNU Makefiles.

With CMake you also get a set of `CMakeLists.txt` files that can now port between Linux, Windows, and macOS systems seamlessly, since they'll all depend only on having the CMake application installed; so as long as you manage all the libraries and other OS-specific dependencies, your build process will at least by easily portable and reusable.

<a id="bazel-build-system"></a>
### Bazel Build System

Bazel is an Open-Source variant of Google's internally developed build system called Blaze, which they released publicly in 2015 under this new name Bazel.

CMake is actually just a tool that generates a bunch of GNU Make Makefiles, and then really just operates as an abstraction/interface to GNU Make.

With Bazel, you have a build management application written in Java which is focused more on project management for many contemporary Programming Languages, not just complied applications. It's both a Build Tool and a Build System, in that it allows you to manage everything without trying to force your way into the assumptions of GNU Make or relying only on the limitations of `bash`.

<a id="references"></a>
## References

- ["List of Build Automation Software" (Wikipedia)](https://en.wikipedia.org/wiki/List_of_build_automation_software)
- [GNU Make](https://www.gnu.org/software/make/)
- [Bazel (Install)](https://bazel.build/install)
- [Bazel (C++ First Project)](https://bazel.build/start/cpp)
- [CMake](https://cmake.org/)
